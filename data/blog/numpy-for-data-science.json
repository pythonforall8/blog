{
  "slug": "numpy-for-data-science",
  "title": "NumPy for Data Science: Essential Arrays and Operations",
  "excerpt": "Master NumPy, the fundamental package for scientific computing in Python, and boost your data science skills.",
  "date": "2025-05-03",
  "coverImage": "https://images.pexels.com/photos/590022/pexels-photo-590022.jpeg",
  "author": {
    "slug": "jyoti-sharma",
    "name": "Jyoti Sharma",
    "title": "Founder & Content Head",
    "bio": "Python educator with over 19 years of teaching experience, dedicated to making programming accessible to everyone.",
    "avatar": "/jyoti-mam.png"
  },
  "categories": [
    {
      "slug": "data-science",
      "name": "Data Science",
      "description": "Topics related to data analysis, visualization, and machine learning"
    },
    {
      "slug": "python-basics",
      "name": "Python Basics",
      "description": "Fundamental concepts and tutorials for Python beginners"
    }
  ],
  "readingTime": 14,
  "content": "# NumPy for Data Science: Essential Arrays and Operations\n\nNumPy (Numerical Python) is the fundamental package for scientific computing in Python. It provides support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.\n\n## Getting Started with NumPy\n\nFirst, you'll need to install NumPy:\n\n```bash\npip install numpy\n```\n\nNow, let's create some basic NumPy arrays:\n\n```python\nimport numpy as np\n\n# Create arrays\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.zeros((3, 3))\narr3 = np.ones((2, 4))\narr4 = np.random.random((2, 2))\n\nprint(\"Array 1:\", arr1)\nprint(\"Array 2:\\n\", arr2)\nprint(\"Array 3:\\n\", arr3)\nprint(\"Array 4:\\n\", arr4)\n```\n\n## Array Creation Functions\n\nNumPy provides many functions to create arrays:\n\n```python\n# Create an array with a range of values\narr5 = np.arange(10)  # [0, 1, 2, ..., 9]\n\n# Create an array with evenly spaced values\narr6 = np.linspace(0, 1, 5)  # [0, 0.25, 0.5, 0.75, 1]\n\n# Create an identity matrix\narr7 = np.eye(3)\n\n# Create an array with random integers\narr8 = np.random.randint(1, 10, size=(3, 3))\n\nprint(\"Array 5:\", arr5)\nprint(\"Array 6:\", arr6)\nprint(\"Array 7:\\n\", arr7)\nprint(\"Array 8:\\n\", arr8)\n```\n\n## Array Indexing and Slicing\n\nNumPy arrays can be indexed and sliced similar to Python lists, but with more capabilities:\n\n```python\n# Create a 2D array\narr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])\n\n# Indexing\nprint(arr[0, 0])  # 1 (first element)\nprint(arr[2, 3])  # 12 (last element)\n\n# Slicing\nprint(arr[0:2, 1:3])  # [[2, 3], [6, 7]]\n\n# Boolean indexing\nprint(arr[arr > 5])  # [6, 7, 8, 9, 10, 11, 12]\n\n# Fancy indexing\nprint(arr[[0, 2], [1, 3]])  # [2, 12]\n```\n\n## Array Operations\n\nNumPy provides a wide range of operations for arrays:\n\n### Element-wise Operations\n\n```python\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\n\n# Addition\nprint(a + b)  # [5, 7, 9]\n\n# Subtraction\nprint(a - b)  # [-3, -3, -3]\n\n# Multiplication\nprint(a * b)  # [4, 10, 18]\n\n# Division\nprint(a / b)  # [0.25, 0.4, 0.5]\n\n# Exponentiation\nprint(a ** 2)  # [1, 4, 9]\n```\n\n### Universal Functions (ufuncs)\n\n```python\n# Mathematical functions\nprint(np.sqrt(a))  # Square root: [1., 1.41421356, 1.73205081]\nprint(np.exp(a))   # Exponential: [2.71828183, 7.3890561, 20.08553692]\nprint(np.log(a))   # Natural logarithm: [0., 0.69314718, 1.09861229]\n\n# Trigonometric functions\nangles = np.array([0, np.pi/2, np.pi])\nprint(np.sin(angles))  # [0., 1., 0.]\nprint(np.cos(angles))  # [1., 0., -1.]\n```\n\n## Array Aggregation\n\nNumPy provides functions to aggregate array values:\n\n```python\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n# Sum\nprint(np.sum(arr))          # 45 (sum of all elements)\nprint(np.sum(arr, axis=0))  # [12, 15, 18] (sum of each column)\nprint(np.sum(arr, axis=1))  # [6, 15, 24] (sum of each row)\n\n# Mean, min, max\nprint(np.mean(arr))  # 5.0\nprint(np.min(arr))   # 1\nprint(np.max(arr))   # 9\n\n# Standard deviation and variance\nprint(np.std(arr))   # 2.581...\nprint(np.var(arr))   # 6.666...\n```\n\n## Broadcasting\n\nNumPy's broadcasting allows operations between arrays of different shapes:\n\n```python\n# Add a scalar to an array\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr + 10)  # [[11, 12, 13], [14, 15, 16]]\n\n# Add a row vector to an array\nrow = np.array([10, 20, 30])\nprint(arr + row)  # [[11, 22, 33], [14, 25, 36]]\n\n# Add a column vector to an array\ncol = np.array([[100], [200]])\nprint(arr + col)  # [[101, 102, 103], [204, 205, 206]]\n```\n\n## Array Reshaping\n\nYou can change the shape of arrays without changing their data:\n\n```python\narr = np.arange(12)\n\n# Reshape to 3x4 array\nreshaped = arr.reshape(3, 4)\nprint(reshaped)\n\n# Flatten an array\nflattened = reshaped.flatten()\nprint(flattened)\n\n# Transpose an array\ntransposed = reshaped.T\nprint(transposed)\n```\n\n## Linear Algebra with NumPy\n\nNumPy provides functions for linear algebra operations:\n\n```python\na = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\n\n# Matrix multiplication\nprint(np.matmul(a, b))  # or use a @ b in Python 3.5+\n\n# Determinant\nprint(np.linalg.det(a))\n\n# Inverse\nprint(np.linalg.inv(a))\n\n# Eigenvalues and eigenvectors\neigenvalues, eigenvectors = np.linalg.eig(a)\nprint(\"Eigenvalues:\", eigenvalues)\nprint(\"Eigenvectors:\\n\", eigenvectors)\n```\n\n## Practical Example: Image Processing\n\nNumPy is often used for image processing, where images are represented as arrays:\n\n```python\n# Create a simple 5x5 image (grayscale)\nimg = np.zeros((5, 5))\nimg[1:4, 1:4] = 1  # Create a white square in the middle\nprint(\"Image:\\n\", img)\n\n# Apply a filter (simple blur)\nkernel = np.ones((3, 3)) / 9  # 3x3 averaging filter\nresult = np.zeros_like(img)\n\nfor i in range(1, img.shape[0]-1):\n    for j in range(1, img.shape[1]-1):\n        result[i, j] = np.sum(img[i-1:i+2, j-1:j+2] * kernel)\n\nprint(\"Filtered image:\\n\", result)\n```\n\n## Performance Tips\n\n1. **Vectorize operations**: Use NumPy's vectorized operations instead of Python loops\n2. **Use appropriate data types**: Choose the smallest data type that fits your data\n3. **Pre-allocate arrays**: Create arrays with the right size upfront instead of growing them\n4. **Use NumPy's built-in functions**: They're optimized for performance\n\n## Conclusion\n\nNumPy is an essential library for data science in Python. Its efficient array operations and mathematical functions make it the foundation for many other data science libraries like Pandas, SciPy, and scikit-learn.\n\nBy mastering NumPy, you'll be well-equipped to tackle more complex data science tasks and work with other libraries in the Python data science ecosystem."
} 