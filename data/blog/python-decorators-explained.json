{
  "slug": "python-decorators-explained",
  "title": "Python Decorators Explained: Understanding Advanced Python Features",
  "excerpt": "Dive into Python decorators and learn how they can help you write cleaner, more maintainable code.",
  "date": "2024-05-04",
  "coverImage": "https://images.pexels.com/photos/2004161/pexels-photo-2004161.jpeg",
  "author": {
    "slug": "samyak-jain",
    "name": "Samyak Jain",
    "title": "Technical Head",
    "bio": "Full-stack developer and Python enthusiast focused on creating intuitive educational resources and tools.",
    "avatar": "/samyak.jpg"
  },
  "categories": [
    {
      "slug": "python-basics",
      "name": "Python Basics",
      "description": "Fundamental concepts and tutorials for Python beginners"
    },
    {
      "slug": "advanced-python",
      "name": "Advanced Python",
      "description": "Advanced Python concepts and techniques for experienced developers"
    }
  ],
  "readingTime": 15,
  "content": "# Python Decorators Explained: Understanding Advanced Python Features\n\nDecorators are one of Python's most powerful features, allowing you to modify the behavior of functions or methods without changing their source code. This concept follows Python's principle of \"open for extension, closed for modification.\"\n\n## Understanding Python Decorators\n\nAt its core, a decorator is a function that takes another function as an argument and extends its behavior without explicitly modifying it.\n\n```python\ndef my_decorator(func):\n    def wrapper():\n        print(\"Something is happening before the function is called.\")\n        func()\n        print(\"Something is happening after the function is called.\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n\n# When you call say_hello()\nsay_hello()\n```\n\nThe output of this code would be:\n\n```\nSomething is happening before the function is called.\nHello!\nSomething is happening after the function is called.\n```\n\n## How Decorators Work\n\nThe `@my_decorator` syntax is just syntactic sugar for:\n\n```python\ndef say_hello():\n    print(\"Hello!\")\n\nsay_hello = my_decorator(say_hello)\n```\n\nThis is why decorators are so powerful - they allow you to modify or extend functions without changing their source code.\n\n## Decorators with Arguments\n\nSometimes you need to pass arguments to the decorated function. Here's how to handle that:\n\n```python\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(\"Before the function call\")\n        result = func(*args, **kwargs)\n        print(\"After the function call\")\n        return result\n    return wrapper\n\n@my_decorator\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Python Developer\")\n```\n\n## Decorators with Parameters\n\nYou can also create decorators that accept parameters:\n\n```python\ndef repeat(n):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            for _ in range(n):\n                result = func(*args, **kwargs)\n            return result\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef say_hi(name):\n    print(f\"Hi, {name}!\")\n    \nsay_hi(\"Python Expert\")  # Will print \"Hi, Python Expert!\" three times\n```\n\n## Practical Examples of Decorators\n\n### Timing Functions\n\n```python\nimport time\n\ndef timing_decorator(func):\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time - start_time:.6f} seconds to run\")\n        return result\n    return wrapper\n\n@timing_decorator\ndef slow_function():\n    time.sleep(1)\n    print(\"Function executed\")\n    \nslow_function()\n```\n\n### Caching Results (Memoization)\n\n```python\ndef memoize(func):\n    cache = {}\n    \n    def wrapper(*args):\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    return wrapper\n\n@memoize\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(35))  # Without memoization, this would be very slow\n```\n\n### Authentication\n\n```python\ndef require_auth(func):\n    def wrapper(user, *args, **kwargs):\n        if not user.is_authenticated:\n            raise PermissionError(\"Authentication required\")\n        return func(user, *args, **kwargs)\n    return wrapper\n\n@require_auth\ndef view_protected_resource(user, resource_id):\n    return f\"User {user.name} is viewing resource {resource_id}\"\n```\n\n## Class Decorators\n\nDecorators can also be applied to classes:\n\n```python\ndef add_greeting(cls):\n    cls.greet = lambda self: f\"Hello, I'm {self.name}\"\n    return cls\n\n@add_greeting\nclass Person:\n    def __init__(self, name):\n        self.name = name\n\nperson = Person(\"John\")\nprint(person.greet())  # Output: Hello, I'm John\n```\n\n## Method Decorators\n\nPython has built-in decorators like `@classmethod`, `@staticmethod`, and `@property`:\n\n```python\nclass Temperature:\n    def __init__(self, celsius=0):\n        self._celsius = celsius\n        \n    @property\n    def celsius(self):\n        return self._celsius\n    \n    @celsius.setter\n    def celsius(self, value):\n        if value < -273.15:\n            raise ValueError(\"Temperature below absolute zero is not possible\")\n        self._celsius = value\n        \n    @property\n    def fahrenheit(self):\n        return self._celsius * 9/5 + 32\n    \n    @fahrenheit.setter\n    def fahrenheit(self, value):\n        self.celsius = (value - 32) * 5/9\n    \n    @classmethod\n    def from_fahrenheit(cls, value):\n        return cls((value - 32) * 5/9)\n```\n\n## Stacking Decorators\n\nYou can apply multiple decorators to a single function:\n\n```python\n@decorator1\n@decorator2\ndef my_function():\n    pass\n```\n\nThis is equivalent to:\n\n```python\nmy_function = decorator1(decorator2(my_function))\n```\n\nThe decorators are applied from bottom to top (decorator2 first, then decorator1).\n\n## Best Practices\n\n1. **Use `functools.wraps`**: This preserves the metadata of the original function\n\n```python\nfrom functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper\n```\n\n2. **Keep decorators simple**: Each decorator should have a single responsibility\n3. **Document what your decorators do**: They can make code harder to understand if not well documented\n\n## Conclusion\n\nDecorators are a powerful Python feature that enables clean, maintainable code by separating concerns and following the principle of \"open for extension, closed for modification.\"\n\nMastering decorators will help you write more elegant, reusable, and maintainable Python code. They're widely used in frameworks like Flask, Django, and many other Python libraries to provide clean APIs and separate cross-cutting concerns from business logic."
} 